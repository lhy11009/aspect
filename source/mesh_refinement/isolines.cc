/*
  Copyright (C) 2011 - 2019 by the authors of the ASPECT code.

  This file is part of ASPECT.

  ASPECT is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.

  ASPECT is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with ASPECT; see the file LICENSE.  If not see
  <http://www.gnu.org/licenses/>.
*/



#include <aspect/mesh_refinement/isolines.h>
#include <aspect/utilities.h>
#include <aspect/geometry_model/interface.h>

#include <deal.II/base/quadrature_lib.h>
#include <deal.II/fe/fe_values.h>
#include <math.h>

namespace aspect
{
  namespace MeshRefinement
  {
    namespace Internal
    {
      bool
      Isoline::values_are_in_range(const std::vector<double> values) const
      {
        // This assumes that all the vectors in isolines already have the
        // same length.
        Assert(values.size() == min_values.size(),
               ExcMessage("Internal error: Vector of values passed to the isoline class function values_are_in_range, "
                          "does not have the the correct size."));
        for (unsigned int index = 0; index < values.size(); ++index)
          {
            if (values[index] < min_values[index] || values[index] < max_values[index])
              {
                // ouside this isoline, no need to search futher
                return false;
              }
          }
        // If we made it this far, then we are inside the conditions, so return true.
        return true;
      }
    }

    template <int dim>
    void
    Isolines<dim>::update ()
    { }

    template <int dim>
    void
    Isolines<dim>::tag_additional_cells () const
    {

      const Quadrature<dim> quadrature(this->get_fe().base_element(this->introspection().base_elements.temperature).get_unit_support_points());
      std::vector<types::global_dof_index> local_dof_indices (this->get_fe().dofs_per_cell);
      FEValues<dim> fe_values (this->get_mapping(),
                               this->get_fe(),
                               quadrature,
                               update_quadrature_points | update_values | update_gradients);


      MaterialModel::MaterialModelInputs<dim> in(quadrature.size(),
                                                 this->n_compositional_fields());
      /**
       * TODO: This is the main function which requires work. It uses a list
       * of parameters which needs to be loaded (generated by the parse function
       * and it doesn't change).
       * 1. Load required parameters
       * 2. per cell:
       * 2.1. use map to determaine the four flag cells based on whether the values are between the isolines
       * 2.2. Use the flags to set either tag a cell for coarsening or refinement
       */


      for (const auto &cell : this->get_dof_handler().active_cell_iterators())
        {
          if (cell->is_locally_owned())
            {
              bool coarsen = false;
              bool clear_refine = false;
              bool refine = false;
              bool clear_coarsen = false;

              fe_values.reinit(cell);
              in.reinit(fe_values, cell, this->introspection(), this->get_solution(), true);

              for (unsigned int i_quad=0; i_quad<quadrature.size(); ++i_quad)
                {
                  for (auto &isoline : isolines)
                    {
                      // setup the vector to theck
                      std::vector<double> values(isoline.min_values.size());
                      for (unsigned int index = 0; index < isoline.properties.size(); ++index)
                        {
                          if (isoline.properties[index].name == Internal::PropertyName::Temperature)
                            {
                              values[index] = in.temperature[i_quad];
                            }
                          else if (isoline.properties[index].name == Internal::PropertyName::Composition)
                            {
                              values[index] = in.composition[i_quad][isoline.properties[index].index];
                            }
                        }

                      if ( isoline.values_are_in_range(values))
                        {
                          // If the current refinement level is smaller or equal to the refinement minimum level, any coarsening flags should be cleared.
                          if (cell->level() <= isoline.min_refinement)
                            {
                              clear_coarsen = true;
                            }

                          // If the current refinement level is smaller then the minimum level, a refinment flag should be placed.
                          if (cell->level() <  isoline.min_refinement)
                            {
                              refine = true;
                              break;
                            }

                          // If the current refinement level is larger or equal to the maximum refinement level, any refinement flag should be cleared.
                          if (cell->level() >= isoline.max_refinement)
                            {
                              clear_refine = true;
                            }

                          // If the current refinement level is larger then the maximum level, a coarsening flag should be placed.
                          if (cell->level() >  isoline.max_refinement)
                            {
                              coarsen = true;
                            }
                        }
                    }
                }

              // if both coarsen and refine are true, give preference to refinement
              if (coarsen == true && refine == true)
                {
                  coarsen = false;
                  clear_refine = false;
                }

              // Perform the actual placement of the coarsening and refinement flags
              // We want to make sure that the refiment never goes below the minimum
              // or above the maximum, so we first check/set the coarsen/refine flag,
              // and then check/set the clear coarsen/refine flag.
              if (coarsen == true)
                {
                  cell->set_coarsen_flag ();
                }
              if (clear_coarsen == true)
                {
                  cell->clear_coarsen_flag ();
                }
              if (refine == true)
                {
                  cell->set_refine_flag ();
                }
              if (clear_refine == true)
                {
                  cell->clear_refine_flag ();
                }
            }
        }
    }

    template <int dim>
    void
    Isolines<dim>::
    declare_parameters (ParameterHandler &prm)
    {
      prm.enter_subsection("Mesh refinement");
      {

        prm.enter_subsection("Isolines");
        {
          /**
           * TODO
           */
          prm.declare_entry ("isolines", "depth",
                             Patterns::Anything(),
                             "Todo");

        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }

    template <int dim>
    void
    Isolines<dim>::parse_parameters (ParameterHandler &prm)
    {
      /**
       * Todo:
       * 1. make enum
       * 2. make container variable in header file
       * 3. read in variables into struct
       */

      // fill parameter list_of_composition_names: Todo: These should be enums
      std::vector<std::string> list_of_composition_names = {"Temperature", "Density", "viscosity", "strain-rate", "Pressure"};
      const std::vector<std::string> compositions = this->introspection().get_composition_names();
      list_of_composition_names.insert(list_of_composition_names.end(), compositions.begin(), compositions.end());

      // parameter has_background_field, what does it do, what do we want?

      prm.enter_subsection("Mesh refinement");
      {
        prm.enter_subsection("Isolines");
        {
          /*isolines = Utilities::parse_map_to_double_array (prm.get("Isolines"), // input_string
                                                           list_of_composition_names, // list_of_keys
                                                           has_background_field, // expects_background_field
                                                           "Isoterms", // property_name
                                                           true, // allow_multiple_values_per_key
                                                           2, // n_values_per_key: check is 2 is correct (min, max)
                                                           true); // allow missing keys: check whether we want true or false*/
          /**
           * Fill in the isolines variable
           */


        }
        prm.leave_subsection();
      }
      prm.leave_subsection();
    }
  }
}

// explicit instantiations
namespace aspect
{
  namespace MeshRefinement
  {
    ASPECT_REGISTER_MESH_REFINEMENT_CRITERION(Isolines,
                                              "isolines",
                                              "Todo")
  }
}
